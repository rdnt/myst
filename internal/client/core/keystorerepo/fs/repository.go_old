package keystorerepo

import (
	"crypto/subtle"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"myst/internal/client/core/keystore_manager/jsonenclave"

	"myst/internal/client/core/keyrepo"

	"myst/internal/client/core/domain/keystore"
	enclave2 "myst/internal/client/core/keystore_manager/enclave"
	"myst/internal/client/core/keystorerepo/jsonkeystore"
	"myst/pkg/crypto"
	"myst/pkg/enclave"
)

const Extention = ".myst"

var (
	ErrAuthenticationFailed = enclave.ErrAuthenticationFailed
)

type repository struct {
	mux     sync.Mutex
	keyRepo *keyrepo.Repository
}

type SealedEnclave struct {
	Salt    []byte `json:"salt"`
	MAC     []byte `json:"mac"`
	Payload []byte `json:"payload"`
}

type Data struct {
	Keystores []jsonkeystore.Keystore `json:"keystores"`
	Keys      map[string][]byte       `json:"keys"`
}

func (r *repository) Create(opts ...keystore.Option) (*keystore.Keystore, error) {
	r.mux.Lock()
	defer r.mux.Unlock()

	k := keystore.New(opts...)

	err := r.createEnclave(k.Password(), k)
	if err != nil {
		return nil, err
	}

	//kpath := "data/keystores/" + k.Id() + Extention
	//
	//if _, err := os.Stat(kpath); err == nil {
	//	return nil, fmt.Errorf("already exists")
	//} else if !errors.Is(err, os.ErrNotExist) {
	//	return nil, err
	//}
	//
	//b, err := jsonkeystore.Marshal(k)
	//if err != nil {
	//	return nil, err
	//}
	//
	//p := crypto.DefaultArgon2IdParams
	//
	//salt, err := crypto.GenerateRandomBytes(uint(p.SaltLength))
	//if err != nil {
	//	return nil, err
	//}
	//
	//key := crypto.Argon2Id([]byte(k.Password()), salt)
	//
	//b, err = enclave.Create(b, key, salt)
	//if err != nil {
	//	return nil, err
	//}
	//
	//err = os.WriteFile(kpath, b, 0600)
	//if err != nil {
	//	return nil, err
	//}
	//
	//err = os.WriteFile("data/key", append(key, salt...), 0600)
	//if err != nil {
	//	return nil, err
	//}
	//
	//r.keyRepo.Set(k.Id(), key)

	return k, nil
}

func (r *repository) createEnclave(password string, k *keystore.Keystore) error {
	p := crypto.DefaultArgon2IdParams

	path := "data/enclave.myst"

	e := enclave2.New(
		enclave2.WithKeystores(k),
	)

	//b, err := jsonkeystore.Marshal(k)
	//if err != nil {
	//	return err
	//}

	salt, err := crypto.GenerateRandomBytes(uint(p.SaltLength))
	if err != nil {
		return err
	}

	keystoreKey, err := crypto.GenerateRandomBytes(uint(p.KeyLength))
	if err != nil {
		return err
	}

	key := crypto.Argon2Id([]byte(password), salt)

	encryptedKeystoreKey, err := crypto.AES256CBC_Encrypt(key, keystoreKey)
	if err != nil {
		return err
	}

	encryptedKeystoreKey, err := crypto.AES256CBC_Encrypt(key, keystoreKey)
	if err != nil {
		return err
	}

	enc := Enclave{
		Salt: salt,
		Keystores: []Keystore{
			{
				Payload: encryptedKeystoreKey,
				Key:     encryptedKeystoreKey,
			},
		},
	}

	b, err := jsonenclave.Marshal(e)
	if err != nil {
		return err
	}

	b, err = crypto.AES256CBC_Encrypt(keystoreKey, append(encryptedKeystoreKey, b...))
	if err != nil {
		return err
	}

	// authenticate
	mac := crypto.HMAC_SHA256(key, b)

	// prepend mac to the ciphertext
	b = append(mac, b...)

	// prepend salt to the mac-ciphertext
	b = append(salt, b...)

	err = os.WriteFile(path, b, 0600)
	if err != nil {
		return err
	}

	return nil
}

func (r *repository) Authenticate(password string) error {
	r.mux.Lock()
	defer r.mux.Unlock()

	kpath := "data/key"

	b, err := os.ReadFile(kpath)
	if err != nil {
		return err
	}

	p := crypto.DefaultArgon2IdParams

	if len(b) != int(p.KeyLength+p.SaltLength) {
		return fmt.Errorf("invalid length")
	}

	expected, salt := b[:p.KeyLength], b[p.KeyLength:]

	key := crypto.Argon2Id([]byte(password), salt)

	if subtle.ConstantTimeCompare(key, expected) != 1 {
		return ErrAuthenticationFailed
	}

	return nil
}

func (r *repository) Unlock(id string, password string) (*keystore.Keystore, error) {
	r.mux.Lock()
	defer r.mux.Unlock()

	kpath := "data/keystores/" + id + Extention

	if _, err := os.Stat(kpath); errors.Is(err, os.ErrNotExist) {
		return nil, keystore.ErrNotFound
	} else if err != nil {
		return nil, err
	}

	b, err := os.ReadFile(kpath)
	if err != nil {
		return nil, err
	}

	salt, err := enclave.GetSaltFromData(b)
	if err != nil {
		return nil, err
	}

	key := crypto.Argon2Id([]byte(password), salt)

	r.keyRepo.Set(id, key)

	return r.keystore(id)
}

func (r *repository) HealthCheck() {
	r.keyRepo.HealthCheck()
}

func (r *repository) Keystore(id string) (*keystore.Keystore, error) {
	r.mux.Lock()
	defer r.mux.Unlock()

	return r.keystore(id)
}

func (r *repository) keystore(id string) (*keystore.Keystore, error) {
	kpath := "data/keystores/" + id + Extention

	if _, err := os.Stat(kpath); errors.Is(err, os.ErrNotExist) {
		return nil, keystore.ErrNotFound
	} else if err != nil {
		return nil, err
	}

	b, err := os.ReadFile(kpath)
	if err != nil {
		return nil, err
	}

	key, err := r.keyRepo.Key(id)
	if err != nil {
		return nil, keystore.ErrAuthenticationRequired
	}

	b, err = enclave.Unlock(b, key)
	if errors.Is(err, enclave.ErrAuthenticationFailed) {
		return nil, ErrAuthenticationFailed
	} else if err != nil {
		return nil, err
	}

	k, err := jsonkeystore.Unmarshal(b)
	if err != nil {
		return nil, err
	}

	return k, nil
}

func (r *repository) Keystores() ([]*keystore.Keystore, error) {
	r.mux.Lock()
	defer r.mux.Unlock()

	ids, err := r.KeystoreIds()
	if err != nil {
		return nil, err
	}

	ks := []*keystore.Keystore{}

	for _, id := range ids {
		k, err := r.keystore(id)
		if err != nil {
			return nil, err
		}

		ks = append(ks, k)
	}

	return ks, nil
}

func (r *repository) Update(k *keystore.Keystore) error {
	r.mux.Lock()
	defer r.mux.Unlock()

	key, err := r.keyRepo.Key(k.Id())
	if err != nil {
		return keystore.ErrAuthenticationRequired
	}

	kpath := "data/keystores/" + k.Id() + Extention

	if _, err := os.Stat(kpath); errors.Is(err, os.ErrNotExist) {
		return keystore.ErrNotFound
	} else if err != nil {
		return err
	}

	// read the existing keystore and get the salt; we will reuse the salt so that we don't have to re-generate the
	// encryption key
	b, err := os.ReadFile(kpath)
	if err != nil {
		return err
	}

	salt, err := enclave.GetSaltFromData(b)
	if err != nil {
		return err
	}

	b, err = jsonkeystore.Marshal(k)
	if err != nil {
		return err
	}

	b, err = enclave.Create(b, key, salt)
	if err != nil {
		return err
	}

	err = os.WriteFile(kpath, b, 0600)
	if err != nil {
		return err
	}

	return nil
}

func (r *repository) KeystoreIds() ([]string, error) {
	fis, err := os.ReadDir("data/keystores")
	if err != nil {
		return nil, err
	}

	ids := []string{}

	for _, fi := range fis {
		if fi.IsDir() {
			continue
		}

		if filepath.Ext(fi.Name()) != Extention {
			continue
		}

		id := strings.TrimSuffix(filepath.Base(fi.Name()), filepath.Ext(Extention))

		ids = append(ids, id)
	}

	return ids, nil
}

func (r *repository) Delete(id string) error {
	r.mux.Lock()
	defer r.mux.Unlock()

	kpath := "data/keystores/" + id + Extention

	if _, err := os.Stat(kpath); errors.Is(err, os.ErrNotExist) {
		return keystore.ErrNotFound
	} else if err != nil {
		return err
	}

	err := os.Remove(kpath)
	if err != nil {
		return err
	}

	r.keyRepo.Delete(id)

	return nil
}

func New() *repository {
	return &repository{
		keyRepo: keyrepo.New(),
	}
}
